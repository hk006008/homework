<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <style type="text/css">
        body {
            background-color: #fff;
            color: #111;
            margin: 0px;
            overflow: hidden;
            font-family: Monospace;
            font-size: 10px;
            position: absolute;
        }
        #info {
            position: absolute;
            top: 3%;
            width: 100%;
            padding: 5px;
            text-align: center;
            color: #ffff00;
        }
    </style>
    <title>hw7  by hk006008</title>
    <script type='text/javascript'>
window.onload=function(){
var renderer, camera, controls;
var pointLight;
var scene, sceneRTT, rtTexture, torus;
var rttmaterial, quad;
var camera2;

init();
animate();

function init()
{

	rtTexture = new THREE.WebGLRenderTarget(
		1024,1024,
		{ minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat }
		);

	renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setSize (window.innerWidth, window.innerHeight);
	document.body.appendChild (renderer.domElement);
	renderer.setClearColor (0x888888);
	renderer.autoClear = false;

	camera = new THREE.PerspectiveCamera (45, window.innerWidth/window.innerHeight, 0.1, 10000);
	camera.position.y = 1100;
	camera.position.z = 1000;
 	camera.position.x = 0;

	camera.lookAt (new THREE.Vector3(0,0,0));

	//camera2 = camera.clone();
  camera2 = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -1000, 1000);
	// add control here (after the camera is defined)
	controls = new THREE.OrbitControls (camera, renderer.domElement);
//////////////////////////////////////////////////////////////////////////
	// render a torus to texture
	// then apply the texture to a quad,
  // with a monochrome filter

	sceneRTT = new THREE.Scene();
	pointLight = new THREE.PointLight (0xffffff);
	pointLight.position.set (0,300,200);
	sceneRTT.add (pointLight);

	torus = new THREE.Mesh (new THREE.TorusGeometry(10, 3, 16, 100),
		new THREE.MeshLambertMaterial({
    color:0xff1234
    }));
	torus.scale.set (10,10,10);
  torus.rotation.x = Math.PI/2;
	sceneRTT.add (torus);

  torus2 = torus.clone();
	torus2.scale.set (10,10,10);
  torus2.position.set(220,0,0);
  torus2.rotation.x = Math.PI/2;
	sceneRTT.add (torus2);

  torus3 = torus.clone();
	torus3.scale.set (10,10,10);
  torus3.position.set(110,0,-220);
  torus3.rotation.x = Math.PI/2;
	sceneRTT.add (torus3);

  torus4 = torus.clone();
	torus4.scale.set (10,10,10);
  torus4.position.set(330,0,-220);
  torus4.rotation.x = -Math.PI/2;
	sceneRTT.add (torus4);

  torus5 = torus.clone();
	torus5.scale.set (10,10,10);
  torus5.position.set(-110,0,-220);
  torus5.rotation.x = Math.PI/2;
	sceneRTT.add (torus5);

	scene = new THREE.Scene();
	rttmaterial = new THREE.ShaderMaterial( {
		depthWrite: false,
    uniforms: {texture: {type: "t",
    value: rtTexture},
    color2: {	type: 'float',
  	value: 0.0}},
		vertexShader: document.getElementById( 'myVertexShader' ).textContent,
		fragmentShader: document.getElementById( 'myFragmentShader' ).textContent}
		);
  //rttmaterial.side = THREE.DoubleSide;

  var plane = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
	quad = new THREE.Mesh (plane, rttmaterial);
	scene.add (quad);
//////////////////////////////////////////////////////////////////////////
  sceneMono = new THREE.Scene();
  pointLight = new THREE.PointLight(0xffffff);
  pointLight.position.set(0, 300, 200);
  /*sceneMono.add(pointLight);

  torus = new THREE.Mesh(new THREE.TorusGeometry(10, 3, 16, 100),
    new THREE.MeshLambertMaterial({
      color: 0x12ffee,
      colorWrite: false
    }));
  torus.scale.set(9, 9, 9);
  torus.rotation.x = Math.PI / 2;*/
  //sceneMono.add(torus);

  sceneColor = new THREE.Scene();
  column = new THREE.Mesh (new THREE.TorusGeometry(10, 2, 16, 100),
		new THREE.MeshLambertMaterial({
    color:0x12ff34
    }));
  column.scale.set (10,10,10);
  column.position.set(110,0,0);

  sceneColor.add(pointLight);
  sceneColor.add(column);
  ////////////////////////////////////////
  var gui = new dat.GUI();
  gui.add(rttmaterial.uniforms.color2, 'value', 0.0, 5.0).name('fade');
}

window.onresize = function () {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize (window.innerWidth, window.innerHeight);
}

function animate()
{
	controls.update();

	requestAnimationFrame ( animate );
	renderer.clear();

  torus.material.colorWrite = true;

 	renderer.setClearColor (0x888800);
	renderer.render (sceneRTT, camera, rtTexture, true);
	// rtTexture has colored torus

	// render texture to screne
  renderer.setClearColor (0x008888);
	renderer.render(scene, camera2);//, rtTexture2, true

  torus.material.colorWrite = false;

  renderer.render(sceneRTT, camera);
  renderer.render(sceneColor, camera);
  // rtTexture2 has monochorme torus
	// render a board with a monochomre background
  // render to depth buffer (no color), the scene
  // render the colored inside cylinder.
  //?? can I disable color buffer output
	//renderer.render (sceneFinal, camera);

}
}
    </script>
</head>
<body>
    <div id="info">
        <br>
        <br> hw7
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
    <script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js">
    </script>

    <script id="myVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
        gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
        vUv = uv;
        }
    </script>
    <script id="myFragmentShader" type="x-shader/x-fragment">
        uniform sampler2D texture;
        uniform float color2;
        varying vec2 vUv;
        vec3 rgb2hsv(vec3 c)
        {
        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c)
        {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
        void main() {
        vec4 color = texture2D (texture, vUv);
        vec3 hsv = rgb2hsv (color.rgb);
        if(color2 >= 4.9) hsv.y = 0.0;
        else if(color2 >= 4.5) hsv.y = 0.05;
        else if(color2 >= 4.0) hsv.y = 0.1;
        else if(color2 >= 3.5) hsv.y = 0.13;
        else
        hsv.y = hsv.y / (color2 + 1.0);
        vec3 rgb = hsv2rgb (hsv.xyz);
        gl_FragColor = vec4 (rgb, 1.0);
        }
    </script>
</body>
</html>
