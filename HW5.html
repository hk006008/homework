<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <style type="text/css">
    #info {
  position: absolute;
  top: 2%;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  margin:0;
  overflow: hidden;
}

  </style>

  <title>hw5 by hk006008</title>

  
</head>

<body>
  <div id="info">
  hw5 <br>GLSL
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script id="myVertexShader" type="x-shader/x-vertex">
  uniform int shading;
  uniform int coordinate;
	varying vec3 color;
	varying vec4 pixel;
  void perVertexShading() {
  	if(coordinate == 0){
      if (position.x > 0.0) 
        color = vec3 (0,0,0);
      else
        color = vec3 (1,1,1);
    }
    if(coordinate == 1){
    	vec4 world = modelMatrix * vec4( position, 1.0 );
    	if(world.x > 0.0)
      	color = vec3 (0,0,0);
      else
        color = vec3 (1,1,1);
    }
    if(coordinate == 2){
    	vec4 eye = modelViewMatrix * vec4( position, 1.0 );
    	if(eye.x > 0.0)
      	color = vec3 (0,0,0);
      else
        color = vec3 (1,1,1);
    }
  }
	void perPixelShading() {
  	if(coordinate == 0){
    	pixel = vec4( position, 1.0 );			
    }
    if(coordinate == 1){
    	pixel = modelMatrix * vec4( position, 1.0 );
    }
    if(coordinate == 2){
    	pixel = modelViewMatrix * vec4( position, 1.0 );    	
    }
  }
	void main() {
		gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
  	if (shading == 0)  // per-vertex shading
    	perVertexShading();
    else
    	perPixelShading();
  }
</script>
<script id="myFragmentShader" type="x-shader/x-fragment">
  uniform int shading;
	varying vec4 pixel;
  varying vec3 color;
	void main() {
  	if(shading == 0)
			gl_FragColor = vec4 (color, 1.0);
    if(shading == 1)
    	if(pixel.x > 0.0)
      	gl_FragColor = vec4 (0,0,0, 1.0);
      else
      	gl_FragColor = vec4 (1,1,1, 1.0);
	}
</script>
<script type='text/javascript'>

var scene, renderer, camera;
var controls;
var jsonModel, jsonModel2;
var angle = 0;

init();
animate();

function init() {
  var width = window.innerWidth;
  var height = window.innerHeight;

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(width, height);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
  camera.position.z = 500;
  camera.lookAt(new THREE.Vector3(0, 0, 0));

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  var gridXZ = new THREE.GridHelper(100, 10);
  gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
  //scene.add(gridXZ);

  pointLight = new THREE.PointLight(0xffffff);
  pointLight.position.set(200, 300, 200);
  //scene.add(pointLight);
  var ambientLight = new THREE.AmbientLight(0x111111);
  scene.add(ambientLight);

/////////////////////////////////////////////
	gcontrols = new function() {
    this.shading = 'per-vertex';
    this.coordinate = 'object';
  }

  var gui = new dat.GUI();
  gui.domElement.id = 'gui';

  

/////////////////////////////////////////////////////////////////
  teapotMaterial = new THREE.ShaderMaterial({
    uniforms: {
			shading: {type:"i",value: 0},
      coordinate: {type:"i",value: 0},
		},
    vertexShader: document.getElementById('myVertexShader').textContent,
    fragmentShader: document.getElementById('myFragmentShader').textContent
  });
var f1 = gui.addFolder("Coordinate System");
  f1.add (teapotMaterial.uniforms.coordinate, 'value', {'object':0, 'world':1, 'eye':2});
  var f2 = gui.addFolder('Shading Computation');
  f2.add (teapotMaterial.uniforms.shading, 'value', {'per-vertex':0, 'per-pixel':1});
  var jsonLoader = new THREE.JSONLoader();
  var url = "https://jyunming-chen.github.io/tutsplus/models/teapot.json";
  jsonLoader.load(url, function(geometry, materials) {
    //var material = new THREE.MeshFaceMaterial(materials);
    jsonModel = new THREE.Mesh(geometry, teapotMaterial);
    jsonModel.scale.set(10, 10, 10);
    scene.add(jsonModel);
//    jsonModel.position.set(70, 0, 0);

    jsonModel2 = jsonModel.clone();
    jsonModel2.position.set(70, 0, 0);
    jsonModel.material = new THREE.MeshLambertMaterial();
    scene.add(jsonModel2);
    ////////////////////////////////////////////////////////
		 // spotlight
 
  	light1.target = jsonModel;/////
    jsonModel.castShadow = true;
  	jsonModel.receiveShadow = true;
		jsonModel2.castShadow = true;
  	jsonModel2.receiveShadow = true; // self shadow
  	/////////////////////////////////////////////////////////
  });
  light = new THREE.Object3D();
  // spotlight
  light1 = new THREE.SpotLight(0xffffff, 0.5);
  light1.position.set(170, 300, 170);
  light1.angle = Math.PI/4;
  light1.exponent = 10;
  //light1.target = jsonModel;/////
  light.add(light1);
  scene.add(light);

  // shadow map settings
  light1.castShadow = true;
  light1.shadowMapWidth = 1024;
  light1.shadowMapHeight = 1024;
  light1.shadowCameraNear = 10;
  light1.shadowCameraFar = 4000;
  light1.shadowCameraFov = light1.angle / Math.PI * 180;


  // directional light
  light2 = new THREE.DirectionalLight(0xffff00);
  light2.position.set(200, 100, 0);
  light2.castShadow = true;
  light2.shadowCameraLeft = -80;
  light2.shadowCameraTop = -80;
  light2.shadowCameraRight = 80;
  light2.shadowCameraBottom = 80;
  light2.shadowCameraNear = 1;
  light2.shadowCameraFar = 1000;
  light2.shadowBias = -.0001
  light2.shadowMapWidth = light2.shadowMapHeight = 1024;
  light2.shadowDarkness = .7;
  //scene.add(light2);

  renderer.shadowMapEnabled = true;
  renderer.shadowMapType = THREE.PCFShadowMap;
  // floor
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(400, 400, 130, 130),
    new THREE.MeshLambertMaterial());
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);

  floor.receiveShadow = true;/////////
  /*jsonModel.castShadow = true;
  jsonModel.receiveShadow = true; // self shadow
  */
}

function animate() {
  angle += 0.01;

  // update the uniform variable
  
	if (jsonModel2 !== undefined) {
		jsonModel2.position.set (70*Math.cos(angle), 0, 70*Math.sin(angle));
  }
  ////////////////////////////////////
  light.rotation.y = -angle;
  ///////////////////////////////////////
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
</script>
</body>
</html>

