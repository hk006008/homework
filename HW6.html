<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <style type="text/css">
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            text-align: center;
            color: #ffff00;
        }
        body {
            overflow: hidden;
        }
    </style>
    <title>hw6 </title>
</head>
<body>
    <div id="info">
        Hw6 <div id="value"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
    <script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">
    </script>
    <script id="myVertexShader" type="x-shader/x-vertex">
        uniform vec3 lightpos;
        varying vec3 eyenormal;
        varying vec3 eyelightdir;
        void main() {
        gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
        vec4 eyepos = modelViewMatrix * vec4 (position, 1.0);
        vec4 eyelightpos= viewMatrix * vec4 (lightpos, 1.0);
        eyelightdir = normalize (eyelightpos.xyz - eyepos.xyz);
        eyenormal = normalMatrix * normal;
        }
    </script>
    <script id="myFragmentShader" type="x-shader/x-fragment">
        uniform float hp;
        varying vec3 eyenormal;
        varying vec3 eyelightdir;
        void main() {
        float ndotl = dot(normalize(eyenormal), normalize(eyelightdir));
        float a = 0.1;
        float b = 0.2;
        vec3 kdiffuse = vec3(1, 1, 1);
        vec3 kcool = vec3(0, 0, 1);
        vec3 kwarm = vec3(1, 1, 0);
        vec3 kcdiff = kcool + a * kdiffuse;
        vec3 kwdiff = kwarm + b * kdiffuse;
        vec3 kfinal = (1.0 + ndotl)/2.0 * kwdiff + (1.0 - (1.0 + ndotl)/2.0) * kcdiff;
        gl_FragColor = vec4 (kfinal, hp);
        }
    </script>
    <script type='text/javascript'>
var scene, renderer, light, sphere;
var raycaster;
var mouse = new THREE.Vector2();
var pickables = [], teapots = [];
var camera, controls, angle = 0, light3d;
var teapotGeometry;
function Teapot(mesh) {///////////////////////////////////
		mesh.scale.set(5,5,5);
	  this.mesh = mesh;
    this.angle = 0;
    this.turn = true;
    this.hp = 1;
}
function findTeapot(mesh) {
	//console.log('target', mesh);
	for (var i = 0; i < teapots.length; i++) {
		//console.log('xxx', teapots[i].mesh);
  	if (teapots[i].mesh === mesh)
    	return teapots[i];
  }
}
// method of Person
Teapot.prototype.update = function () {
    if (this.turn) {
    	this.angle += 0.01;
      this.hp -= 0.001;///////////
    }
    this.mesh.rotation.y = this.angle;
    this.mesh.material.uniforms.hp.value = this.hp;
	if(this.hp <= 0){
  	this.expire();
  }
};
Teapot.prototype.expire = function (){
  for (var i = 0; i < teapots.length; i++) {
  	if(teapots[i] == this)	{
    	teapots.splice(i, 1);
    	break;
    }
	}
  scene.remove(this.mesh);
};
/////////////////////////////////////////////////

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.z = 200;
  camera.position.y = 200;

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  light = new THREE.PointLight(0xffffff);
  light.position.set(100, 300, 200);
  light3d = new THREE.Object3D();
  light3d.add(light);
  scene.add(light3d);

  var gridXZ = new THREE.GridHelper(100, 10);
  gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
  //scene.add(gridXZ);

  //////////////////////////////////////////////////////////
	var ground = new THREE.Mesh (new THREE.PlaneGeometry (200,200),
  new THREE.MeshPhongMaterial({color:0xff7834}));
  scene.add (ground);
  ground.rotation.x = -Math.PI/2;

  var platform = new THREE.Mesh (new THREE.BoxGeometry (50,10,80),
  new THREE.MeshLambertMaterial({transparent:true, opacity:0.5}));
	platform.position.set (60,0,30);
  var platform2 = platform.clone();
  platform2.position.set (-60,0,-30);
  scene.add (platform2);
  scene.add (platform);
  /////////////////////////////

  var jsonLoader = new THREE.JSONLoader();
  var url = "https://jyunming-chen.github.io/tutsplus/models/teapot.json";
  jsonLoader.load(url, function(geometry, materials) {
    teapotGeometry = geometry;
  });
  /////////////////////////////////////////////////////////////////////////////

	sphere = new THREE.Mesh(new THREE.SphereGeometry(5,12,12),
    new THREE.MeshLambertMaterial({
      color: 0x1287ff
    }));
  //scene.add(sphere);
  pickables.push(ground);

  raycaster = new THREE.Raycaster();
  document.addEventListener('mousedown', onDocumentMouseDown, false);

}

function onDocumentMouseDown(event) {
  // only handles right button click....
	if(event.which ===1){
  	event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(teapots.map(function (x){return x.mesh}));
  	if (intersects.length > 0) {
        var teapot = findTeapot (intersects[0].object);
    	//console.log(intersects, intersects[0].object, teapot)
        teapot.turn = !teapot.turn;
    }
  }
  if (event.which === 3){

    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    var intersects = raycaster.intersectObjects(pickables);

    if (intersects.length > 0) {  // inside picking plane
      var origin = new THREE.Vector3();
      origin.copy (intersects[0].point);
      origin.y = 30;

      raycaster.set (origin, new THREE.Vector3(0,-1,0));
      intersects = raycaster.intersectObjects (scene.children);
      if (intersects.length > 0) {////////////////////////////////////////////
        var teapot1 = new THREE.Mesh(teapotGeometry,new THREE.ShaderMaterial({
  	transparent: true,
    uniforms: {
    	hp: {
      type:'f',
      value:1
      },
      lightpos: {
      type: 'v3',
      value: light.position
      }
		},
    vertexShader: document.getElementById('myVertexShader').textContent,
    fragmentShader: document.getElementById('myFragmentShader').textContent
  }));
        teapot1.position.copy(intersects[0].point);
        scene.add(teapot1);
        var teapot2 = new Teapot(teapot1);
        teapots.push(teapot2);
      }///////////////////////////////////////////////////////////////////////


    }
  }
}
function update() {
	for (var i = 0; i < teapots.length; i++) {
  	teapots[i].update();
  }
}
function animate() {
	document.getElementById("value").innerHTML = teapots.length;
  angle += 0.01;
  light3d.rotation.y = -angle;
	update();
  controls.update();
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
    </script>
</body>
</html>